clc
clear all

elec = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25,...
        1.25, 1.25, 1, 1, 1, 1, 1, 1, 1];

d0 = [131.62, 127.23, 128.25, 137.21, 188.79, 216.03, 242.64, 245.35,...
      213.04, 217.24, 237.6, 202, 212, 200, 185, 196.49, 212.93,...
      237.57, 283.49, 290.08, 236.54, 190, 185, 155];
 
comb1_flows = 250;
comb2_flows = 250;
comb3_flows = 400;
 
comb1_power = 100;
comb2_power = 95;
comb3_power = 172;
 
well_flows = 300;
well_power = 126;

T = 24;
v0 = 1500;
vfinal = 1500;
vmin = 500;
vmax = 2800;
theta = 0.1;

model = rsome();
model.Param.solver = 'gurobi';

x = model.decision(4, T); % Create a decision variable x

model.min(sum(comb1_power * x(1, :) .* elec +...
              comb2_power * x(2, :) .* elec +...
              comb3_power * x(3, :) .* elec +...
              well_power * x(4, :) .* elec));

model.append(0 <= x);
model.append(x <= 1);

for t = 1:1:T
    model.append(x(1, t) + x(2, t) + x(3, t) <= 1);
    model.append(v0 + sum(x(1, 1:t)) * comb1_flows...
                    + sum(x(2, 1:t)) * comb2_flows...
                    + sum(x(3, 1:t)) * comb3_flows...
                    + sum(x(4, 1:t)) * well_flows...
                    - sum(d0(1:t)) >= vmin)
    model.append(v0 + sum(x(1, 1:t)) * comb1_flows...
                    + sum(x(2, 1:t)) * comb2_flows...
                    + sum(x(3, 1:t)) * comb3_flows...
                    + sum(x(4, 1:t)) * well_flows...
                    - sum(d0(1:t)) <= vmax)
end

model.append(v0 + sum(x(1, 1:T)) * comb1_flows...
                    + sum(x(2, 1:T)) * comb2_flows...
                    + sum(x(3, 1:T)) * comb3_flows...
                    + sum(x(4, 1:T)) * well_flows...
                    - sum(d0(1:T)) >= v0)


model.solve; 
Obj = model.get
X = x.get; % Get the optimal solution of x
vol = v0 + cumsum(X(1, :) * comb1_flows + ...
                  X(2, :) * comb2_flows + ...
                  X(3, :) * comb3_flows + ...
                  X(4, :) * well_flows) - ...
            cumsum(d0);